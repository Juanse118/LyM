/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi


 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;

	static HashMap<String,Integer > Vars= new HashMap<String,Integer >();

	static HashMap<String,String > Funcs= new HashMap<String,Integer >();

	static HashMap<String,Integer > VarsActuales= Vars;
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	" "
	|	"\r"
	|	"\t"
	| "\n"
}

TOKEN : /* PARENTESIS */
{
< AC:"[" >
| < CC:"]" >
| < BARRA:"|" >
}

TOKEN : /* PUNTUACION */
{
 < COMA :"," >
| < PUNTO :"." >
| < DOSPUNTOS:":" >
| < PUNTOC:";" >
}


TOKEN: /* Cmds nuevos */
{

			<AssignTo:  "assignTo">
		| 	<Goto: "goto">
		| 	<Move: "move">
		| 	<Turn: "turn">
		|  < Face: "face" >
		|  <Put: "put" >
        |  < Pick:  "pick" >
        |  < MoveToThe:  "moveToThe" >
        |  < MoveInDir:  "moveInDir" >
        |  < JumpToThe:  "jumpToThe" >
        |  < JumpInDir:  "jumpInDir" >
        |  < Nop:  "nop" >
        	
}

TOKEN: /* Condicionales */
{

			<If:  "if">
		| 	<Then: "then">
		| 	<Else: "else">
		| 	<While: "while">
		|  < Do: "do" >
		|  <Repeat: "repeat" >
        	
}


TOKEN: /* Condiciones */
{

		< COND: ("facing" 
		| "canPut" 
		| "canPick" 
		| "canMoveInDir" 
		|  "canJumpInDir" 
		|  "canMoveToThe" 
        |  "canJumpToThe") > 
        | < NOT:  "not" >
        	
}

TOKEN: /*Cardinales/directions*/
{
		
		  <CARD:  ("north" 
		|   "south"  
		|    "east"  
		|    "west"  )>
		| 	<DIR:  ("front" 
		|   "right"  
		|    "left"  
		|    "back"  )>	
}

TOKEN:
{
		<BALLOONS:  "BALLOONS" >
		|	<CHIPS:     "CHIPS"  >	

}

TOKEN: /*varios*/
{
		<ROBOT_R:  "ROBOT_R" >
		|	<VARS:     "VARS"  >
		| < PROCS: "PROCS" >	

}

TOKEN : /* NUM & LETRAS */
{
  < NUM : ("-")?(< DIGIT >)+ >
| < NOM : (< LETTER >)+ >
| < PAL : "\""(< NOM >|" "|< PUNTO >| < BARRA >|< COMA >|< PUNTOC >)+"\"" >
| < #DIGIT : ["0"-"9"] >
| < #LETTER : ["a"-"z"] | ["A"-"Z"] | "_" >
}



	//boolean command(uniandes.lym.robot.view.Console sistema) :
	boolean command(Console sistema):
	{	
		
		int x,y;
		salida=new String();

	}

	
	{

		< ROBOT_R >(varDec(Vars))?< PROCS> (funcDef())* < AC >programa()< CC > /* no se como hacer que se guarden globalmente las var*/

	  
	}

	/* var dec */

	void varDec():
	{ }
	{
	< VARS >(<NOM > {  String variables = token.image;
	Vars.put(variables,null);

	} <COMA >)*< NOM >
	{  String variables = token.image;
	Vars.put(variables,null);
	}<PUNTOC >


	}
	/* revision de var */

	void var():
	{ }
	{
	< NOM > {
	  	valor = null;
		if (VarsActuales.ContainsKey(token.image)) {
		  Integer valor = VarsActuales.getValue(token.image);
		  if (valor.equals(null)) {
		    System.out.println("No se ha asignado un valor a la variable");
			throw new ParseException("Variable vacia");
		  }
		}else {
			System.out.println("Variable llamada antes de ser instanciada");
			throw new ParseException("Variable no existe");
		  }
			
	  }
	}

	/* Func Def */

	void funcDef():
	{ String nombre = null;
	Integer count = 0;
	/*ArrayList< String> varLocales = new ArrayList<String >*/;}
	{
	< NOM > { nombre = token.image; }<AC ><BARRA >((< NOM > { count += 1;
	/*varLocales.add(token.image)*/ VarsActuales.put(nombre,token.image);
	 }<COMA >)*< NOM> { count += 1;
	/*varLocales.add(token.image)*/VarsActuales.put(nombre,token.image);
	Funcs.put(nombre,count);
	 })?<BARRA >(cuerpo())* { VarsActuales = Vars; }<CC >
}

	/* programa real */

	void programa():
	{ }
	{
	((cuerpo() < PUNTOC >|funcionE()< PUNTOC >)*(cuerpo()|funcionE()))?
	}

	/* Revisar funcion extra */

	void funcionE():
	{String nomFunc = null;
	String cuerpoFunc = null;
	Integer count = 0; }
	{
	< NOM > { nomFunc = token.image;
	if (Funcs.containsKey(nomFunc)) {
		cuerpoFunc = Funcs.getValue(nomFunc);
	} else { System.out.println("Funcion llamada antes de declaracion");
			throw new ParseException("Funcion llamada antes de declaracion"); }


	}<DOSPUNTOS >((<NUM > {
		count +=1;
		}
	  <COMA >)*(<NUM >{
		count +=1;
		}))?
	{
	if (!count.equals(cuerpoFunc)) {
		System.out.println("Parametros incorrectos");
		throw new ParseException("Parametros incorrectos");
	}
	}
	}

	/* cuerpo */

	void cuerpo():
	{ }
	{
	(
	  conditional()
	| loop()
	| rep()
	| gotof()
	| move()
	| turn()
	| face()
	| put()
	| pick()
	| moveToThe()
	| moveInDir()
	| jumpToThe()
	| jumpInDir()
	| nop())
}

	/* definicion estrucutra conds */

	void conditional():
	{ }
	{
	< If ><DOSPUNTOS >(< NOT >)?<COND ><Then ><DOSPUNTOS >cuerpo()< Else ><DOSPUNTOS >cuerpo()
	}

	void loop():
	{ }
	{
	< While ><DOSPUNTOS >(< NOT >)?<COND ><Do ><DOSPUNTOS >cuerpo()
	}

	void rep():
	{ }
	{
	< Repeat ><DOSPUNTOS >(< NUM>|var())cuerpo()
	}
	

	/* definicion estructura cmds */

	void assignTo():
	{ Integer val = null;}
	{
	< AssignTo ><DOSPUNTOS >(< NUM>|var())
	{
	 Integer val = Integer.parseInt(token.image);
	}
	< COMA ><PAL >
	{
	String nom = token.image;
	if (Vars.containsKey(nom)) { 
		Vars.put(nom,val);}
	}
	}

	

	void gotof():
	{ }
	{
	< Goto ><DOSPUNTOS >(< NUM>|var()) < COMA>(< NUM>|var())
	}

	void move():
	{ }
	{
	< Move ><DOSPUNTOS >(< NUM>|var())
	}

	void turn():
	{ }
	{
	< Turn ><DOSPUNTOS ><DIR >
	}

	void face():
	{ }
	{
	< Face ><DOSPUNTOS ><CARD >
	}

	void put():
	{ }
	{
	< Put ><DOSPUNTOS >(< NUM>|var())<COMA >(< BALLOONS >|< CHIPS >)
	}

	void pick():
	{ }
	{
	< Pick ><DOSPUNTOS >(< NUM>|var())<COMA >(< BALLOONS >|< CHIPS >)
	}

	void moveToThe():
	{ }
	{
	< MoveToThe ><DOSPUNTOS >(< NUM>|var())<COMA ><DIR >
	}

	void moveInDir():
	{ }
	{
	< MoveInDir ><DOSPUNTOS >(< NUM>|var())<COMA ><CARD >
	}


	void jumpToThe():
	{ }
	{
	< JumpToThe ><DOSPUNTOS >(< NUM>|var())<COMA ><DIR >
	}

	void jumpInDir():
	{ }
	{
	< JumpInDir ><DOSPUNTOS >(< NUM>|var())<COMA ><CARD >
	}

	void nop():
	{}
	{
	<Nop>
	}
